package Solver;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;
import java.util.Set;


import ETP.*;

/**
 * 
 * This class is intended to search for the best solution, given an initial one, by running the Tabu Search algorithm
 *
 */

class Tabu {

	/**
	 * 
	 * This classe encode the concept of exam's move by wrapping togheter all the information about a move
	 *
	 */
	class Move{
	
		Exam e1, e2; //move from e1 to e2
		Integer t1, t2;
		
		/**
		 * Returns a Move object generated by a swap between e1 and e2.
		 * In order to avoid order dependencies of (e1, t1, e2, t2) that can produce the same move encoded in 2 different ways,
		 * we declare e1 to be the exam with the lower ID and t1 the correspondant timeslot of e1.
		 * Tha case e1 == e2 is not handled by this class and must be avoided from the outside.
		 * 
		 * @param e1 first exam
		 * @param t1 current timeslot of e1
		 * @param e2 second exam
		 * @param t2 current timeslot of e2
		 */
		public Move(Exam e1, Integer t1, Exam e2, Integer t2) {

			Comparator<Exam> comp = Exam.compareByName();
			if(comp.compare(e1, e2) == -1) {
				this.e1 = e1;
				this.t1 = t1;
				this.e2 = e2;
				this.t2 = t2;
			}
			else { //change the order
				this.e1 = e2;
				this.t1 = t2;
				this.e2 = e1;
				this.t2 = t1;
			}	
		}
		
		/**
		 * 
		 * @param e exam to be moved
		 * @param tNew the final timeslot of the exam
		 * @param tOld the current timeslot of the exam
		 */
		public Move(Exam e, Integer tNew, Integer tOld) {
			
			this.e1 = e;
			this.t1 = tNew;
			this.t2 = tOld;
			this.e2 = null;
		}


		@Override
		public boolean equals(Object o) {
			// e1 it's never equals to null
			if(o instanceof Move) {
				
				if(this.t1.equals(((Move) o).t1) && this.t2.equals(((Move) o).t2)) {
					
					if(this.e1.equals(((Move) o).e1)) {
						if(this.e2 == null && ((Move) o).e2 == null)
							return true;
						else	
							if(this.e2 != null && ((Move) o).e2 != null && this.e2.equals(((Move) o).e2))
								return true;
					}
				}
			}
			
			return false;
		}
		

		@Override
		public int hashCode() {
			//the hashcode for an integer is the effective value of the integer
			if(e2 == null)
				return Integer.valueOf(this.e1.getId()).hashCode();
			else
				return (Integer.valueOf(this.e1.getId()).hashCode() << 16 | Integer.valueOf(this.e2.getId()).hashCode());
		}
	}	
		
	
	
	
	
	private Solution bestSolution;
	private List<Solution> tabuList; //FIFO : used to remove the oldest explored solution
	private Set<Solution> tabuSet; //used to efficiently check the presence of a solution
	private Integer I; // iterations #
	private long tMax; //maximum time to run
	
	
	/*
	 * PARAMETERS TO BE CALIBRATED
	 */
	private Integer neighSize;				//=	100;
	private Integer listSize;				//=	2*neighSize;
	private Double p;				        //=	0.2; 			//penalty for unfeasible solution
	private Double aspirationThreshold;      //=   0.025;


	
	/**
	 * This method was thought to set the tabu parameters from a configurator object
	 * 
	 * @param cf the configuration object from which get the parameter's values
	 */
	public Tabu(Configurator cf) {
		this.neighSize = cf.neighSize;
		this.listSize = cf.listSize;
		this.p = cf.p;
		this.aspirationThreshold = cf.aspirationThreshold;
		
		
		this.tabuList = new LinkedList<>(); //FIFO
		this.tabuSet = new HashSet<>();
		this.I = 0;

	}
	
	/**
	 * This method is called to run the Tabu Search
	 * 
	 * @param initialSol solution from which to start the search
	 * @param tMax the max execution time for the algorithm
	 * @return the best solution found or null in the case no better solution was found
	 */
	public Solution run(Solution initialSol, int tMax) {
		Solution currentSol = initialSol;
		Solution fixed;
		this.tabuList.add(initialSol);
		this.tabuSet.add(initialSol);
		this.bestSolution = currentSol;
		List<Solution> neigh = new ArrayList<>();
		Solution tmp;
		
		this.tMax = tMax;
		long start = System.currentTimeMillis();
		
		while( (System.currentTimeMillis() - start) < this.tMax) {
			
			neigh = this.steepestDescent(currentSol);
			
			tmp = searchForTheBest(neigh);
			if(tmp == null) {
				if(currentSol.getFatherSol() != null)
					currentSol = currentSol.getFatherSol();
				continue; //all the neigh is tabu
			}
			else {
				currentSol = tmp;
			}

				
			if(this.I >= 0 && !currentSol.isFeasible() && currentSol.getNumConflicts() < 5) {
				
				fixed = tryToFix(currentSol);
				if(fixed.getNumConflicts() < currentSol.getNumConflicts()) {
					
					if(!this.tabuContains(fixed)) {
						
						currentSol = fixed;
						this.tabuInsertion(currentSol);
						
					}

				}
					
					
				this.checkIfBest(fixed);
			}
			
			this.I ++;	//next iteration
		}
		
		if(this.bestSolution.equals(initialSol)) {
			return null;
		}

		return new Solution(this.bestSolution);
	}
	
	
	/**
	 * Neighbourhood generation based on a Steepest Descent local search
	 * 
	 * @param currentSol solution from which to generate the neighbourhood by applying moves
	 * @return the generated neighbourhood
	 */
	private List<Solution> steepestDescent(Solution currentSol) {
		int x = 0;
		
		Exam e1, e2;
		Solution candidate = null;
		List<Solution> neigh = new ArrayList<>(); //candidate solution of the neighborhood and the move that generate him
		Set<Move> move = new HashSet<>(); //to record the already done move in this neighborhood
		Move currentMove = null;
		Random num=new Random();
		Double p;
		int t1, t2;
		
		while(x < this.neighSize) {			
			p = Math.random();
			
			if(p < 0.5) {
				//do change
				t1 = num.nextInt(currentSol.getNumSlots());
				e1 = currentSol.getRandomExam(t1);
				t2 = num.nextInt(currentSol.getNumSlots());
				
				if(t1==t2 || e1 == null)
					continue; //not allowed move
				
				//e1 from t1 to t2
				currentMove = new Move(e1, t2, t1);
				if(!move.contains(currentMove))
					candidate = new Solution(currentSol, e1, t1, t2);
				else
					continue; //already done move for this neighborhood
				
			}
			else {
				//do swap
				t1 = num.nextInt(currentSol.getNumSlots());
				e1 = currentSol.getRandomExam(t1);
				t2 = num.nextInt(currentSol.getNumSlots());
				e2 = currentSol.getRandomExam(t2);
				
				if(t1 == t2 || e1 == null || e2 == null)
					continue; //not allowed move
				
				currentMove = new Move(e1, t2, e2, t1);
				if(!move.contains(currentMove)) {
					candidate = new Solution(currentSol, e1, t2, e2, t1); //we put e2 into t1
				}	
									
			}			

			move.add(currentMove); //records the current move				
					
			neigh.add(candidate);
			x ++;

		}
		
				
		return neigh;
	}
	
	
	/**
	 * Search for the best solution inside a given neighbourhood
	 * 
	 * @param neigh the neighbourhood
	 * @return the best solution inside this neighborhood
	 */
	private Solution searchForTheBest(List<Solution> neigh) {
		
		Solution bestOne = null;
		
		for(int i = 0; i < this.neighSize; i ++) {
			if(!this.tabuContains(neigh.get(i)) && neigh.get(i).getNumConflicts() < 5) {
				bestOne = neigh.get(i);
				break;
			}
		}
		
		if(bestOne == null)
			return null; //no valid solution, try to generate a new neighborhood
		
		
		this.checkIfBest(bestOne);

		
		//best searching . . .
		
		for(Solution s : neigh) {
			
			if(s.getNumConflicts() <= bestOne.getNumConflicts() && s.getRank() + this.p*s.getNumConflicts() < bestOne.getRank() + this.p*bestOne.getNumConflicts() && (!this.tabuContains(s) || this.aspirationCriterion(s))) {
				bestOne = s;	
			}
				
			//lookin at the best unfeasible also i can descard a new feasible best, so i have to record it
			this.checkIfBest(bestOne);
								
		}
		

		//insert in the tabu list the solution
		if(!this.tabuContains(bestOne)) {
			this.tabuInsertion(bestOne);
		}
		else { //already in the TL but aspiration criteria satisfied : move this solution to the tail
			this.tabuToTheTail(bestOne);
			
		}	
		
		return bestOne;
	}
	
	
	
	/**
	 * 
	 * @param sol solution on which to check the aspiration criterion
	 * @return the criterion's outcome
	 */
	private boolean aspirationCriterion(Solution sol) {

		if(sol.getRank() - this.bestSolution.getRank() < this.aspirationThreshold) { // if it's distant less than 15% from the current best
			return true;
		}
		
		return false;
	}
	
	/**
	 * Check if a given solution is tabu
	 * 
	 * @param sol the solution
	 * @return true if this solution is tabu, false otherwise
	 */
	private boolean tabuContains(Solution sol) {
		return this.tabuSet.contains(sol);
	}
	
	/**
	 * Make a solution tabu
	 * 
	 * @param sol solution
	 */
	private void tabuInsertion(Solution sol) {
		this.tabuList.add(sol);
		this.tabuSet.add(sol);
		if(this.tabuList.size() > this.listSize) {
			Solution removed = this.tabuList.remove(0);
			this.tabuSet.remove(removed);
		}
	}
	
	/**
	 * Move a solution the tail of the tabu list
	 * 
	 * @param sol solution to be moved
	 */
	private void tabuToTheTail(Solution sol) {
		this.tabuList.remove(sol);
		this.tabuList.add(sol); //move to tail
	}
	
	

	/**
	 * A simple heuristic that tries to decrease the conflicts number of a solution by move conflicting exams
	 * 
	 * @param s the solution to be fixed
	 * @return a new solution if the previous one has been fixed, the previous one otherwise
	 */
	private Solution tryToFix(Solution s) {
		Integer ts, tTry;
		Exam e;
		Solution tmp;
		// TODO : duplicate conflicts should be handled
		for(Exam ei : s.getExamsClashing().keySet()) {
			
			for(Exam ej : s.getExamsClashing().get(ei)) {
				
				for(int i = 0; i < 2; i ++) {
					
					ts = s.getSlot(ei);
					
					if(i == 0)
						e = ei;
					else
						e = ej;

					tTry = 0;
					do {
						
						tmp = new Solution(s, e, ts, tTry);
						tTry ++;
						
					}while(tmp.getNumConflicts() >= s.getNumConflicts() && tTry < tmp.getNumSlots());
					
					
					// DO NOT TAKE CARE ABOUT THE RANK, WE WANT ONLY TO FIX
					if(tmp.getNumConflicts() < s.getNumConflicts()) {
						s = tmp;	
						return s;
					}

				}
				
				
				
			}
		}
		
		return s;
	}
	
	
	/**
	 * Check if a solution is the best found so far, in that case it saves and put it into the tabu list
	 * 
	 * @param sol solution to be checked
	 */
	private void checkIfBest(Solution sol) {
		if(sol.isFeasible() && sol.getRank() < this.bestSolution.getRank()) {
			this.bestSolution = sol;
		}
		this.tabuInsertion(sol);
	}


}
